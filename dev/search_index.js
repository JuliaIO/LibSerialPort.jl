var documenterSearchIndex = {"docs":
[{"location":"wrap/#Low-level-C-API-wrappers","page":"Low-level C API wrappers","title":"Low-level C API wrappers","text":"","category":"section"},{"location":"wrap/","page":"Low-level C API wrappers","title":"Low-level C API wrappers","text":"Modules = [LibSerialPort.Lib]","category":"page"},{"location":"wrap/#LibSerialPort.Lib","page":"Low-level C API wrappers","title":"LibSerialPort.Lib","text":"The LibSerialPort.Lib module provides a low-level Julia wrapper around each of the C function, types and constants exported by the C library libserialport. The wrapper functions very closely follow the C API, but they check for error codes returned and raise these as a Julia ErrorException.\n\n\n\n\n\n","category":"module"},{"location":"wrap/#LibSerialPort.Lib.sp_blocking_write-Union{Tuple{T}, Tuple{Ref{LibSerialPort.Lib.SPPort}, Union{Ptr{T}, Ref{T}}}, Tuple{Ref{LibSerialPort.Lib.SPPort}, Union{Ptr{T}, Ref{T}}, Integer}, Tuple{Ref{LibSerialPort.Lib.SPPort}, Union{Ptr{T}, Ref{T}}, Integer, Integer}} where T","page":"Low-level C API wrappers","title":"LibSerialPort.Lib.sp_blocking_write","text":"function sp_blocking_write(port::Port, buffer::Union{Ref{T},Ptr{T}},\n                           n::Integer = 1; timeout_ms::Integer = 0) where T`\n\nWrite the sizeof(T)*n bytes starting from address buffer to the specified serial port, blocking until complete.\n\nNote that this function only ensures that the accepted bytes have been written to the OS; they may be held in driver or hardware buffers and not yet physically transmitted. To check whether all written bytes have actually been transmitted, use the sp_output_waiting() function. To wait until all written bytes have actually been transmitted, use the sp_drain() function.\n\nWait up to timeout_ms milliseconds, where zero means to wait indefinitely.\n\nReturns the number of bytes written on success, or raises an ErrorException. If the number of bytes returned is less than that requested, the timeout was reached before the requested number of bytes was written. If timeout_ms is zero, the function will always return either the requested number of bytes or raise an ErrorException. In the event of an error there is no way to determine how many bytes were sent before the error occured.\n\n\n\n\n\n","category":"method"},{"location":"wrap/#LibSerialPort.Lib.sp_drain-Tuple{Ref{LibSerialPort.Lib.SPPort}}","page":"Low-level C API wrappers","title":"LibSerialPort.Lib.sp_drain","text":"sp_drain(port::Port)\nsp_drain(SerialPort::Port)\n\nWait for buffered data to be transmitted.\n\n\n\n\n\n","category":"method"},{"location":"wrap/#LibSerialPort.Lib.sp_flush-Tuple{Ref{LibSerialPort.Lib.SPPort}, SPBuffer}","page":"Low-level C API wrappers","title":"LibSerialPort.Lib.sp_flush","text":"sp_flush(port::Port, buffers::SPBuffer)\nsp_flush(port::SerialPort, buffers::SPBuffer)\n\nDiscard data in the selected serial-port buffer(s).\n\nSupported values for buffers: SP_BUF_INPUT, SP_BUF_OUTPUT, SP_BUF_BOTH\n\nReturns SP_OK upon success or raises an ErrorException otherwise.\n\nnote: Note\nNot to be confused with Base.flush, which writes out buffered data rather than discarding it: the underlying libserialport C library unfortunately uses the verb “flush” differently from its normal meaning for Base.IO (sp_drain provides the latter in this library).\n\n\n\n\n\n","category":"method"},{"location":"wrap/#LibSerialPort.Lib.sp_input_waiting-Tuple{Ref{LibSerialPort.Lib.SPPort}}","page":"Low-level C API wrappers","title":"LibSerialPort.Lib.sp_input_waiting","text":"Returns the number of bytes in the input buffer.\n\n\n\n\n\n","category":"method"},{"location":"wrap/#LibSerialPort.Lib.sp_nonblocking_write-Union{Tuple{T}, Tuple{Ref{LibSerialPort.Lib.SPPort}, Union{Ptr{T}, Ref{T}}}, Tuple{Ref{LibSerialPort.Lib.SPPort}, Union{Ptr{T}, Ref{T}}, Integer}} where T","page":"Low-level C API wrappers","title":"LibSerialPort.Lib.sp_nonblocking_write","text":"sp_nonblocking_write(port::Port, buffer::Union{Ptr{T},Ref{T}},\n                     n::Integer = 1) where T`\n\nWrite the up to sizeof(T)*n bytes starting from address buffer to the specified serial port, without blocking.\n\nNote that this function only ensures that the accepted bytes have been written to the OS; they may be held in driver or hardware buffers and not yet physically transmitted. To check whether all written bytes have actually been transmitted, use the sp_output_waiting() function. To wait until all written bytes have actually been transmitted, use the sp_drain() function.\n\nReturns the number of bytes written on success, or raises an ErrorException. The number of bytes returned may be any number from zero to the maximum that was requested.\n\n\n\n\n\n","category":"method"},{"location":"wrap/#LibSerialPort.Lib.sp_output_waiting-Tuple{Ref{LibSerialPort.Lib.SPPort}}","page":"Low-level C API wrappers","title":"LibSerialPort.Lib.sp_output_waiting","text":"Returns the number of bytes in the output buffer.\n\n\n\n\n\n","category":"method"},{"location":"#LibSerialPort.jl-–-access-serial-ports","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.jl – access serial ports","text":"","category":"section"},{"location":"","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.jl – access serial ports","text":"LibSerialPort","category":"page"},{"location":"#LibSerialPort","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort","text":"The LibSerialPort module provides access to serial ports (UARTs or USB/Bluetooth devices that emulate their operating-system interface) using the portable C library libserialport.\n\nIt defines the SerialPort type, which is returned by LibSerialPort.open. This is a subtype of Base.IO and can therefore be used like a file handle, using many of the same read, write, print, etc. methods defined for Base.IO.\n\nExample\n\nusing LibSerialPort\n\nlist_ports()\nports = get_port_list()\n\nsp = LibSerialPort.open(\"/dev/ttyUSB0\", 115200)\nset_flow_control(sp)\nsp_flush(sp, SP_BUF_BOTH)\nwrite(sp, \"hello\\n\")\nprintln(readline(sp))\nclose(sp)\n\n\n\n\n\n","category":"module"},{"location":"#Enumerating-serial-ports","page":"LibSerialPort.jl – access serial ports","title":"Enumerating serial ports","text":"","category":"section"},{"location":"","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.jl – access serial ports","text":"list_ports\nget_port_list\nprint_port_metadata","category":"page"},{"location":"#LibSerialPort.list_ports","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.list_ports","text":"list_ports([nports_guess::Integer])`\n\nPrint a list of currently visible ports, along with some basic info.\n\nnports_guess provides the number of ports guessed. Its default is 64.\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.get_port_list","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.get_port_list","text":"get_port_list([nports_guess::Integer])\n\nReturn a vector of currently visible ports.\n\nnports_guess provides the number of ports guessed. Its default is 64.\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.print_port_metadata","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.print_port_metadata","text":"print_port_metadata(sp::SerialPort; show_config::Bool = true)\n\nPrint info found for this port. Note: port should be open to obtain a valid FD/handle before accessing fields.\n\nshow_config is true by default and prints out the current port settings.\n\n\n\n\n\n","category":"function"},{"location":"#Opening-and-configuring-ports","page":"LibSerialPort.jl – access serial ports","title":"Opening and configuring ports","text":"","category":"section"},{"location":"","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.jl – access serial ports","text":"LibSerialPort.open(::AbstractString, ::Integer)\nSerialPort(::AbstractString)\nopen(::SerialPort; ::SPMode)\nclose(sp::SerialPort)\nset_speed\nset_frame\nset_flow_control\nisopen(sp::SerialPort)\neof(sp::SerialPort)\nseteof\nget_port_settings\nprint_port_settings\nset_read_timeout\nset_write_timeout\nclear_read_timeout\nclear_write_timeout\nsp_flush\nsp_drain\nsp_output_waiting","category":"page"},{"location":"#Base.open-Tuple{AbstractString, Integer}","page":"LibSerialPort.jl – access serial ports","title":"Base.open","text":"open(portname::AbstractString, baudrate::Integer;\n     mode::SPMode, ndatabits::Integer,\n     parity::SPParity, nstopbits::Integer)\n\nConstruct, configure and open a SerialPort object.\n\nportname is the name of the serial port to open. Typical port names available depend on the operating system. Some valid names are listed by get_port_list(), but there are can be others and aliases:\nLinux: \"/dev/ttyS0\", \"/dev/ttyUSB0\", \"/dev/serial/by-id/...\"\nmacOS: \"/dev/cu.usbserial-0001\", \"/dev/cu.Bluetooth-Incoming-Port\"\nWindows: \"COM1\", \"COM2\",\"COM3\"\nbaudrate is the data signalling rate, or the reciprocal duration of one data bit, in bits/s. The set of values supported depends on the UART hardware, but typically includes e.g. 9600, 19200 and 115200.\nmode selects in which direction of transmission access is requested and can take the values: SP_MODE_READ, SP_MODE_WRITE, and SP_MODE_READ_WRITE (default).\n\nThe parameters ndatabits, parity and nstopbits have the same meaning as in set_frame and default to the common “8N1” frame format (8 data bits, no parity, one stop bit).\n\nTo set the flow-control method, use set_flow_control.\n\n\n\n\n\n","category":"method"},{"location":"#LibSerialPort.SerialPort-Tuple{AbstractString}","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.SerialPort","text":"SerialPort(portname::AbstractString)\n\nConstructs and returns a SerialPort object.\n\n\n\n\n\n","category":"method"},{"location":"#Base.open-Tuple{SerialPort}","page":"LibSerialPort.jl – access serial ports","title":"Base.open","text":"open(sp::SerialPort; mode::SPMode = SP_MODE_READ_WRITE)\n\nOpen the serial port sp.\n\nmode selects in which direction of transmission access is requested and can take the values: SP_MODE_READ, SP_MODE_WRITE, and SP_MODE_READ_WRITE (default).\n\n\n\n\n\n","category":"method"},{"location":"#Base.close-Tuple{SerialPort}","page":"LibSerialPort.jl – access serial ports","title":"Base.close","text":"close(sp::SerialPort)\n\nClose the serial port sp.\n\n\n\n\n\n","category":"method"},{"location":"#LibSerialPort.set_speed","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.set_speed","text":"set_speed(sp::SerialPort, baudrate::Integer)\n\nSet the data signalling rate, or the reciprocal duration of one data bit, in bits/s. The set of values supported depends on the UART hardware, but typically includes e.g. 9600, 19200 and 115200.\n\nRaise an ErrorException if bps is not a value supported by the driver or hardware.\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.set_frame","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.set_frame","text":"set_frame(sp::SerialPort;\n          ndatabits::Integer = 8,\n          parity::SPParity   = SP_PARITY_NONE,\n          nstopbits::Integer = 1)\n\nConfigure the data framing parameters. Defaults to the very common “8N1” scheme, which consists of a start bit followed by eight data bits, no parity bit, one stop bit.\n\nfor more details.\n\nndatabits is the number of data bits, which is 8 in the common \"8N1\" scheme\nparity controls the presence and value of a party bit and can take the values SP_PARITY_NONE (default), SP_PARITY_ODD, SP_PARITY_EVEN, SP_PARITY_MARK and SP_PARITY_SPACE\nnstopbits sets the number of stop bits, typically 1 (default) or 2\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.set_flow_control","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.set_flow_control","text":"set_flow_control(sp::SerialPort;\n                 rts::SPrts = SP_RTS_OFF,\n                 cts::SPcts = SP_CTS_IGNORE,\n                 dtr::SPdtr = SP_DTR_OFF,\n                 dst::SPdsr = SP_DSR_IGNORE,\n                 xonxoff::SPXonXoff = SP_XONXOFF_DISABLED)\n\nConfigure the flow-control lines and method. Many systems don't support all options. If an unsupported option is requested, the library will return SP_ERR_SUPP.\n\nrts controls the output line Ready To Send (RTS) and can take the values SP_RTS_OFF (default), SP_RTS_ON and SP_RTS_FLOW_CONTROL.\ncts controls the input line Clear To Send (CTS) and can take the values SP_CTS_IGNORE (default) and SP_CTS_FLOW_CONTROL\ndtr controls the output line Data Terminal Ready (DTR) and can take the values SP_DTR_OFF (default), SP_DTR_ON, and SP_DTR_FLOW_CONTROL\ndsr controls the input line Data Set Ready (DSR) and can take the values SP_DSR_IGNORE (default) and SP_DSR_FLOW_CONTROL\nxonxoff controls whether software flow control via the control bytes XOFF (pause transmission, 0x13, Ctrl-S) and XON (resume transmission, 0x11, Ctrl-Q) is active, and in which direction; it can take the values: SP_XONXOFF_DISABLED (default), SP_XONXOFF_IN, SP_XONXOFF_OUT, and SP_XONXOFF_INOUT\n\n\n\n\n\n","category":"function"},{"location":"#Base.isopen-Tuple{SerialPort}","page":"LibSerialPort.jl – access serial ports","title":"Base.isopen","text":"isopen(sp::SerialPort) -> Bool\n\nDetermine whether a SerialPort object is open.\n\n\n\n\n\n","category":"method"},{"location":"#Base.eof-Tuple{SerialPort}","page":"LibSerialPort.jl – access serial ports","title":"Base.eof","text":"eof(sp::SerialPort) -> Bool\n\nReturn the “end-of-file” state (true or false). Since serial ports do not have any standard mechanism for signalling the end of a transmitted file, this is just a dummy function that returns whatever Boolean value eof was previously set with seteof(sp, eof). Returns false by default.\n\n\n\n\n\n","category":"method"},{"location":"#LibSerialPort.seteof","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.seteof","text":"seteof(sp::SerialPort, state::Bool)\n\nSet the return value of eof(sp) to state.\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.get_port_settings","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.get_port_settings","text":"get_port_settings(sp::SerialPort)\n\nReturn port settings for sp as a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.print_port_settings","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.print_port_settings","text":"print_port_settings(sp::SerialPort)\n\nPrint port settings for sp.\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.set_read_timeout","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.set_read_timeout","text":"set_read_timeout(sp::SerialPort, seconds::Real)\n\nSet a read timeout limit of t > 0 seconds for the total (cumulative) time that subsequently called blocking read functions can wait before a Timeout exception is thrown.\n\nExample\n\nsp=LibSerialPort.open(\"/dev/ttyUSB0\", 115200)\n# wait until either two lines have been received\n# or 10 seconds have elapsed\nset_read_timeout(sp, 10)\ntry\n    line1 = readuntil(sp, '\\n')\n    line2 = readuntil(sp, '\\n')\ncatch e\n    if isa(e, LibSerialPort.Timeout)\n        println(\"Too late!\")\n    else\n        rethrow()\n    end\nend\nclear_read_timeout(sp)\n\nSee also: clear_read_timeout, set_write_timeout\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.set_write_timeout","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.set_write_timeout","text":"set_write_timeout(sp::SerialPort, seconds::Real)\n\nSet a write timeout limit of t > 0 seconds for the total (cumulative) time that subsequently called blocking read functions can wait before a Timeout exception is thrown.\n\nExample\n\nsp=LibSerialPort.open(\"/dev/ttyUSB0\", 300)\n# wait until either 4000 periods have been\n# passed on to the serial-port driver or\n# 10 seconds have elapsed\nset_write_timeout(sp, 10)\ntry\n    for i=1:50 ; write(sp, '.' ^ 80); end\ncatch e\n    if isa(e, LibSerialPort.Timeout)\n        println(\"This took too long!\")\n    else\n        rethrow()\n    end\nend\nclear_write_timeout(sp)\n\nSee also: clear_write_timeout, set_read_timeout\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.clear_read_timeout","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.clear_read_timeout","text":"clear_read_timeout(sp::SerialPort)\n\nCancel any previous read timeout, such that blocking read operations will now wait without any time limit.\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.clear_write_timeout","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.clear_write_timeout","text":"clear_write_timeout(sp::SerialPort)\n\nCancel any previous write timeout, such that blocking write operations will block without any time limit.\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.Lib.sp_flush","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.Lib.sp_flush","text":"sp_flush(port::Port, buffers::SPBuffer)\nsp_flush(port::SerialPort, buffers::SPBuffer)\n\nDiscard data in the selected serial-port buffer(s).\n\nSupported values for buffers: SP_BUF_INPUT, SP_BUF_OUTPUT, SP_BUF_BOTH\n\nReturns SP_OK upon success or raises an ErrorException otherwise.\n\nnote: Note\nNot to be confused with Base.flush, which writes out buffered data rather than discarding it: the underlying libserialport C library unfortunately uses the verb “flush” differently from its normal meaning for Base.IO (sp_drain provides the latter in this library).\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.Lib.sp_drain","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.Lib.sp_drain","text":"sp_drain(port::Port)\nsp_drain(SerialPort::Port)\n\nWait for buffered data to be transmitted.\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.Lib.sp_output_waiting","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.Lib.sp_output_waiting","text":"Returns the number of bytes in the output buffer.\n\n\n\n\n\n","category":"function"},{"location":"#Read-and-write-methods-from-Base","page":"LibSerialPort.jl – access serial ports","title":"Read and write methods from Base","text":"","category":"section"},{"location":"","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.jl – access serial ports","text":"Many of the read/write methods defined in Base that operate on an object of type IO can also be used with objects of type SerialPort. Therefore, also consult the documentation for","category":"page"},{"location":"","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.jl – access serial ports","text":"Base.read(::IO, ::Any)\nBase.read!\nBase.readbytes!\nBase.readchomp\nBase.readavailable\nBase.readline\nBase.readlines\nBase.eachline\nBase.write\nBase.print(::IO, ::Any)","category":"page"},{"location":"#Additional-read-methods","page":"LibSerialPort.jl – access serial ports","title":"Additional read methods","text":"","category":"section"},{"location":"","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.jl – access serial ports","text":"read(::SerialPort)\nnonblocking_read(::SerialPort)\nbytesavailable(::SerialPort)","category":"page"},{"location":"#Base.read-Tuple{SerialPort}","page":"LibSerialPort.jl – access serial ports","title":"Base.read","text":"read(sp::SerialPort)\n\nReturn all incoming bytes currently available in the UART as a Vector{UInt8}.\n\nnote: Note\nJulia's Base module defines read(s::IO, nb::Integer = typemax(Int)). This method overrides the default value nb to bytesavailable(sp), which is useful for this context.\n\n\n\n\n\n","category":"method"},{"location":"#LibSerialPort.nonblocking_read-Tuple{SerialPort}","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.nonblocking_read","text":"nonblocking_read(sp::SerialPort)\n\nRead everything from the specified serial ports sp input buffer, one byte at a time, until it is empty. Returns a String.\n\n\n\n\n\n","category":"method"},{"location":"#Base.bytesavailable-Tuple{SerialPort}","page":"LibSerialPort.jl – access serial ports","title":"Base.bytesavailable","text":"bytesavailable(sp::SerialPort)\n\nReturn the number of bytes waiting in the input buffer.\n\n\n\n\n\n","category":"method"}]
}
