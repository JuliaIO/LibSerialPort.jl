var documenterSearchIndex = {"docs":
[{"location":"wrap/#Low-level-C-API-wrappers","page":"Low-level C API wrappers","title":"Low-level C API wrappers","text":"","category":"section"},{"location":"wrap/","page":"Low-level C API wrappers","title":"Low-level C API wrappers","text":"Modules = [LibSerialPort.Lib]","category":"page"},{"location":"wrap/#LibSerialPort.Lib","page":"Low-level C API wrappers","title":"LibSerialPort.Lib","text":"The LibSerialPort.Lib module provides a low-level Julia wrapper around each of the C function, types and constants exported by the C library libserialport. The wrapper functions very closely follow the C API, but they check for error codes returned and raise these as a Julia ErrorException.\n\n\n\n\n\n","category":"module"},{"location":"wrap/#LibSerialPort.Lib.sp_blocking_write-Union{Tuple{T}, Tuple{Ref{LibSerialPort.Lib.SPPort}, Union{Ptr{T}, Ref{T}}}, Tuple{Ref{LibSerialPort.Lib.SPPort}, Union{Ptr{T}, Ref{T}}, Integer}, Tuple{Ref{LibSerialPort.Lib.SPPort}, Union{Ptr{T}, Ref{T}}, Integer, Integer}} where T","page":"Low-level C API wrappers","title":"LibSerialPort.Lib.sp_blocking_write","text":"function sp_blocking_write(port::Port, buffer::Union{Ref{T},Ptr{T}},\n                           n::Integer = 1; timeout_ms::Integer = 0) where T`\n\nWrite the sizeof(T)*n bytes starting from address buffer to the specified serial port, blocking until complete.\n\nNote that this function only ensures that the accepted bytes have been written to the OS; they may be held in driver or hardware buffers and not yet physically transmitted. To check whether all written bytes have actually been transmitted, use the sp_output_waiting() function. To wait until all written bytes have actually been transmitted, use the sp_drain() function.\n\nWait up to timeout_ms milliseconds, where zero means to wait indefinitely.\n\nReturns the number of bytes written on success, or raises an ErrorException. If the number of bytes returned is less than that requested, the timeout was reached before the requested number of bytes was written. If timeout_ms is zero, the function will always return either the requested number of bytes or raise an ErrorException. In the event of an error there is no way to determine how many bytes were sent before the error occured.\n\n\n\n\n\n","category":"method"},{"location":"wrap/#LibSerialPort.Lib.sp_drain-Tuple{Ref{LibSerialPort.Lib.SPPort}}","page":"Low-level C API wrappers","title":"LibSerialPort.Lib.sp_drain","text":"sp_drain(port::Port)\nsp_drain(SerialPort::Port)\n\nWait for buffered data to be transmitted.\n\n\n\n\n\n","category":"method"},{"location":"wrap/#LibSerialPort.Lib.sp_flush-Tuple{Ref{LibSerialPort.Lib.SPPort}, SPBuffer}","page":"Low-level C API wrappers","title":"LibSerialPort.Lib.sp_flush","text":"sp_flush(port::Port, buffers::SPBuffer)\nsp_flush(port::SerialPort, buffers::SPBuffer)\n\nDiscard data in the selected serial-port buffer(s).\n\nSupported values for buffers: SP_BUF_INPUT, SP_BUF_OUTPUT, SP_BUF_BOTH\n\nReturns SP_OK upon success or raises an ErrorException otherwise.\n\nnote: Note\nNot to be confused with Base.flush, which writes out buffered data rather than discarding it: the underlying libserialport C library unfortunately uses the verb “flush” differently from its normal meaning for Base.IO (sp_drain provides the latter in this library).\n\n\n\n\n\n","category":"method"},{"location":"wrap/#LibSerialPort.Lib.sp_input_waiting-Tuple{Ref{LibSerialPort.Lib.SPPort}}","page":"Low-level C API wrappers","title":"LibSerialPort.Lib.sp_input_waiting","text":"Returns the number of bytes in the input buffer.\n\n\n\n\n\n","category":"method"},{"location":"wrap/#LibSerialPort.Lib.sp_nonblocking_write-Union{Tuple{T}, Tuple{Ref{LibSerialPort.Lib.SPPort}, Union{Ptr{T}, Ref{T}}}, Tuple{Ref{LibSerialPort.Lib.SPPort}, Union{Ptr{T}, Ref{T}}, Integer}} where T","page":"Low-level C API wrappers","title":"LibSerialPort.Lib.sp_nonblocking_write","text":"sp_nonblocking_write(port::Port, buffer::Union{Ptr{T},Ref{T}},\n                     n::Integer = 1) where T`\n\nWrite the up to sizeof(T)*n bytes starting from address buffer to the specified serial port, without blocking.\n\nNote that this function only ensures that the accepted bytes have been written to the OS; they may be held in driver or hardware buffers and not yet physically transmitted. To check whether all written bytes have actually been transmitted, use the sp_output_waiting() function. To wait until all written bytes have actually been transmitted, use the sp_drain() function.\n\nReturns the number of bytes written on success, or raises an ErrorException. The number of bytes returned may be any number from zero to the maximum that was requested.\n\n\n\n\n\n","category":"method"},{"location":"wrap/#LibSerialPort.Lib.sp_output_waiting-Tuple{Ref{LibSerialPort.Lib.SPPort}}","page":"Low-level C API wrappers","title":"LibSerialPort.Lib.sp_output_waiting","text":"Returns the number of bytes in the output buffer.\n\n\n\n\n\n","category":"method"},{"location":"#LibSerialPort.jl-–-access-serial-ports","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.jl – access serial ports","text":"","category":"section"},{"location":"","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.jl – access serial ports","text":"LibSerialPort","category":"page"},{"location":"#LibSerialPort","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort","text":"The LibSerialPort module provides access to serial ports (UARTs or USB/Bluetooth devices that emulate their operating-system interface) using the portable C library libserialport.\n\nIt defines the SerialPort type, which is returned by LibSerialPort.open. This is a subtype of Base.IO and can therefore be used like a file handle, using many of the same read, write, print, etc. methods defined for Base.IO.\n\nExample\n\nusing LibSerialPort\n\nlist_ports()\nports = get_port_list()\n\nsp = LibSerialPort.open(\"/dev/ttyUSB0\", 115200)\nset_flow_control(sp)\nsp_flush(sp, SP_BUF_BOTH)\nwrite(sp, \"hello\\n\")\nprintln(readline(sp))\nclose(sp)\n\n\n\n\n\n","category":"module"},{"location":"#Enumerating-serial-ports","page":"LibSerialPort.jl – access serial ports","title":"Enumerating serial ports","text":"","category":"section"},{"location":"","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.jl – access serial ports","text":"list_ports\nget_port_list\nprint_port_metadata","category":"page"},{"location":"#LibSerialPort.list_ports","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.list_ports","text":"list_ports([nports_guess::Integer])`\n\nPrint a list of currently visible ports, along with some basic info.\n\nnports_guess provides the number of ports guessed. Its default is 64.\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.get_port_list","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.get_port_list","text":"get_port_list([nports_guess::Integer])\n\nReturn a vector of currently visible ports.\n\nnports_guess provides the number of ports guessed. Its default is 64.\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.print_port_metadata","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.print_port_metadata","text":"print_port_metadata(sp::SerialPort; show_config::Bool = true)\n\nPrint info found for this port. Note: port should be open to obtain a valid FD/handle before accessing fields.\n\nshow_config is true by default and prints out the current port settings.\n\n\n\n\n\n","category":"function"},{"location":"#Opening-and-configuring-ports","page":"LibSerialPort.jl – access serial ports","title":"Opening and configuring ports","text":"","category":"section"},{"location":"","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.jl – access serial ports","text":"LibSerialPort.open(::AbstractString, ::Integer)\nSerialPort(::AbstractString)\nopen(::SerialPort; ::SPMode)\nclose(sp::SerialPort)\nset_speed\nset_frame\nset_flow_control\nisopen(sp::SerialPort)\neof(sp::SerialPort)\nseteof\nget_port_settings\nprint_port_settings\nset_read_timeout\nset_write_timeout\nclear_read_timeout\nclear_write_timeout\nsp_flush\nsp_drain\nsp_output_waiting","category":"page"},{"location":"#Base.open-Tuple{AbstractString, Integer}","page":"LibSerialPort.jl – access serial ports","title":"Base.open","text":"open(portname::AbstractString, baudrate::Integer;\n     mode::SPMode, ndatabits::Integer,\n     parity::SPParity, nstopbits::Integer)\n\nConstruct, configure and open a SerialPort object.\n\nportname is the name of the serial port to open. Typical port names available depend on the operating system. Some valid names are listed by get_port_list(), but there are can be others and aliases:\nLinux: \"/dev/ttyS0\", \"/dev/ttyUSB0\", \"/dev/serial/by-id/...\"\nmacOS: \"/dev/cu.usbserial-0001\", \"/dev/cu.Bluetooth-Incoming-Port\"\nWindows: \"COM1\", \"COM2\",\"COM3\"\nbaudrate is the data signalling rate, or the reciprocal duration of one data bit, in bits/s. The set of values supported depends on the UART hardware, but typically includes e.g. 9600, 19200 and 115200.\nmode selects in which direction of transmission access is requested and can take the values: SP_MODE_READ, SP_MODE_WRITE, and SP_MODE_READ_WRITE (default).\n\nThe parameters ndatabits, parity and nstopbits have the same meaning as in set_frame and default to the common “8N1” frame format (8 data bits, no parity, one stop bit).\n\nTo set the flow-control method, use set_flow_control.\n\n\n\n\n\n","category":"method"},{"location":"#LibSerialPort.SerialPort-Tuple{AbstractString}","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.SerialPort","text":"SerialPort(portname::AbstractString)\n\nConstructs and returns a SerialPort object.\n\n\n\n\n\n","category":"method"},{"location":"#Base.open-Tuple{SerialPort}","page":"LibSerialPort.jl – access serial ports","title":"Base.open","text":"open(sp::SerialPort; mode::SPMode = SP_MODE_READ_WRITE)\n\nOpen the serial port sp.\n\nmode selects in which direction of transmission access is requested and can take the values: SP_MODE_READ, SP_MODE_WRITE, and SP_MODE_READ_WRITE (default).\n\n\n\n\n\n","category":"method"},{"location":"#Base.close-Tuple{SerialPort}","page":"LibSerialPort.jl – access serial ports","title":"Base.close","text":"close(sp::SerialPort)\n\nClose the serial port sp.\n\n\n\n\n\n","category":"method"},{"location":"#LibSerialPort.set_speed","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.set_speed","text":"set_speed(sp::SerialPort, baudrate::Integer)\n\nSet the data signalling rate, or the reciprocal duration of one data bit, in bits/s. The set of values supported depends on the UART hardware, but typically includes e.g. 9600, 19200 and 115200.\n\nRaise an ErrorException if bps is not a value supported by the driver or hardware.\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.set_frame","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.set_frame","text":"set_frame(sp::SerialPort;\n          ndatabits::Integer = 8,\n          parity::SPParity   = SP_PARITY_NONE,\n          nstopbits::Integer = 1)\n\nConfigure the data framing parameters. Defaults to the very common “8N1” scheme, which consists of a start bit followed by eight data bits, no parity bit, one stop bit.\n\nfor more details.\n\nndatabits is the number of data bits, which is 8 in the common \"8N1\" scheme\nparity controls the presence and value of a party bit and can take the values SP_PARITY_NONE (default), SP_PARITY_ODD, SP_PARITY_EVEN, SP_PARITY_MARK and SP_PARITY_SPACE\nnstopbits sets the number of stop bits, typically 1 (default) or 2\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.set_flow_control","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.set_flow_control","text":"set_flow_control(sp::SerialPort;\n                 rts::SPrts = SP_RTS_OFF,\n                 cts::SPcts = SP_CTS_IGNORE,\n                 dtr::SPdtr = SP_DTR_OFF,\n                 dst::SPdsr = SP_DSR_IGNORE,\n                 xonxoff::SPXonXoff = SP_XONXOFF_DISABLED)`\n\nConfigure the flow-control lines and method. Many systems don't support all options. If an unsupported option is requested, the library will return SPERRSUPP.\n\nrts controls the output line Ready To Send (RTS) and can take the values SP_RTS_OFF (default), SP_RTS_ON and SP_RTS_FLOW_CONTROL.\ncts controls the input line Clear To Send (CTS) and can take the values SP_CTS_IGNORE (default) and SP_CTS_FLOW_CONTROL\ndtr controls the output line Data Terminal Ready (DTR) and can take the values SP_DTR_OFF (default), SP_DTR_ON, and SP_DTR_FLOW_CONTROL\ndsr controls the input line Data Set Ready (DSR) and can take the values SP_DSR_IGNORE (default) and SP_DSR_FLOW_CONTROL\nxonxoff controls whether software flow control via the control bytes XOFF (pause transmission, 0x13, Ctrl-S) and XON (resume transmission, 0x11, Ctrl-Q) is active, and in which direction; it can take the values: SP_XONXOFF_DISABLED (default), SP_XONXOFF_IN, SP_XONXOFF_OUT, and SP_XONXOFF_INOUT\n\n\n\n\n\n","category":"function"},{"location":"#Base.isopen-Tuple{SerialPort}","page":"LibSerialPort.jl – access serial ports","title":"Base.isopen","text":"isopen(sp::SerialPort) -> Bool\n\nDetermine whether a SerialPort object is open.\n\n\n\n\n\n","category":"method"},{"location":"#Base.eof-Tuple{SerialPort}","page":"LibSerialPort.jl – access serial ports","title":"Base.eof","text":"eof(sp::SerialPort) -> Bool\n\nReturn the “end-of-file” state (true or false). Since serial ports do not have any standard mechanism for signalling the end of a transmitted file, this is just a dummy function that returns whatever Boolean value eof was previously set with seteof(sp, eof). Returns false by default.\n\n\n\n\n\n","category":"method"},{"location":"#LibSerialPort.seteof","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.seteof","text":"seteof(sp::SerialPort, state::Bool)\n\nSet the return value of eof(sp) to state.\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.get_port_settings","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.get_port_settings","text":"get_port_settings(sp::SerialPort)\n\nReturn port settings for sp as a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.print_port_settings","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.print_port_settings","text":"print_port_settings(sp::SerialPort)\n\nPrint port settings for sp.\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.set_read_timeout","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.set_read_timeout","text":"set_read_timeout(sp::SerialPort, seconds::Real)\n\nSet a read timeout limit of t > 0 seconds for the total (cumulative) time that subsequently called blocking read functions can wait before a Timeout exception is thrown.\n\nExample\n\nsp=LibSerialPort.open(\"/dev/ttyUSB0\", 115200)\n# wait until either two lines have been received\n# or 10 seconds have elapsed\nset_read_timeout(sp, 10)\ntry\n    line1 = readuntil(sp, '\\n')\n    line2 = readuntil(sp, '\\n')\ncatch e\n    if isa(e, LibSerialPort.Timeout)\n        println(\"Too late!\")\n    else\n        rethrow()\n    end\nend\nclear_read_timeout(sp)\n\nSee also: clear_read_timeout, set_write_timeout\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.set_write_timeout","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.set_write_timeout","text":"set_write_timeout(sp::SerialPort, seconds::Real)\n\nSet a write timeout limit of t > 0 seconds for the total (cumulative) time that subsequently called blocking read functions can wait before a Timeout exception is thrown.\n\nExample\n\nsp=LibSerialPort.open(\"/dev/ttyUSB0\", 300)\n# wait until either 4000 periods have been\n# passed on to the serial-port driver or\n# 10 seconds have elapsed\nset_write_timeout(sp, 10)\ntry\n    for i=1:50 ; write(sp, '.' ^ 80); end\ncatch e\n    if isa(e, LibSerialPort.Timeout)\n        println(\"This took too long!\")\n    else\n        rethrow()\n    end\nend\nclear_write_timeout(sp)\n\nSee also: clear_write_timeout, set_read_timeout\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.clear_read_timeout","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.clear_read_timeout","text":"clear_read_timeout(sp::SerialPort)\n\nCancel any previous read timeout, such that blocking read operations will now wait without any time limit.\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.clear_write_timeout","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.clear_write_timeout","text":"clear_write_timeout(sp::SerialPort)\n\nCancel any previous write timeout, such that blocking write operations will block without any time limit.\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.Lib.sp_flush","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.Lib.sp_flush","text":"sp_flush(port::Port, buffers::SPBuffer)\nsp_flush(port::SerialPort, buffers::SPBuffer)\n\nDiscard data in the selected serial-port buffer(s).\n\nSupported values for buffers: SP_BUF_INPUT, SP_BUF_OUTPUT, SP_BUF_BOTH\n\nReturns SP_OK upon success or raises an ErrorException otherwise.\n\nnote: Note\nNot to be confused with Base.flush, which writes out buffered data rather than discarding it: the underlying libserialport C library unfortunately uses the verb “flush” differently from its normal meaning for Base.IO (sp_drain provides the latter in this library).\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.Lib.sp_drain","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.Lib.sp_drain","text":"sp_drain(port::Port)\nsp_drain(SerialPort::Port)\n\nWait for buffered data to be transmitted.\n\n\n\n\n\n","category":"function"},{"location":"#LibSerialPort.Lib.sp_output_waiting","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.Lib.sp_output_waiting","text":"Returns the number of bytes in the output buffer.\n\n\n\n\n\n","category":"function"},{"location":"#Read-and-write-methods-from-Base","page":"LibSerialPort.jl – access serial ports","title":"Read and write methods from Base","text":"","category":"section"},{"location":"","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.jl – access serial ports","text":"Many of the read/write methods defined in Base that operate on an object of type IO can also be used with objects of type SerialPort. Therefore we repeat the documentation of some of these here. (Note that some of the following docstings also refer to other methods that are not applicable to SerialPort.)","category":"page"},{"location":"","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.jl – access serial ports","text":"Base.read(::IO, ::Any)\nBase.read!\nBase.readbytes!\nBase.readchomp\nBase.readavailable\nBase.readline\nBase.readlines\nBase.eachline\nBase.write\nBase.print(::IO, ::Any)","category":"page"},{"location":"#Base.read-Tuple{IO, Any}","page":"LibSerialPort.jl – access serial ports","title":"Base.read","text":"read(io::IO, T)\n\nRead a single value of type T from io, in canonical binary representation.\n\nNote that Julia does not convert the endianness for you. Use ntoh or ltoh for this purpose.\n\nread(io::IO, String)\n\nRead the entirety of io, as a String (see also readchomp).\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> read(io, Char)\n'J': ASCII/Unicode U+004A (category Lu: Letter, uppercase)\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> read(io, String)\n\"JuliaLang is a GitHub organization\"\n\n\n\n\n\n","category":"method"},{"location":"#Base.read!","page":"LibSerialPort.jl – access serial ports","title":"Base.read!","text":"read!(stream::IO, array::AbstractArray)\nread!(filename::AbstractString, array::AbstractArray)\n\nRead binary data from an I/O stream or file, filling in array.\n\n\n\n\n\n","category":"function"},{"location":"#Base.readbytes!","page":"LibSerialPort.jl – access serial ports","title":"Base.readbytes!","text":"readbytes!(stream::IO, b::AbstractVector{UInt8}, nb=length(b))\n\nRead at most nb bytes from stream into b, returning the number of bytes read. The size of b will be increased if needed (i.e. if nb is greater than length(b) and enough bytes could be read), but it will never be decreased.\n\n\n\n\n\nreadbytes!(stream::IOStream, b::AbstractVector{UInt8}, nb=length(b); all::Bool=true)\n\nRead at most nb bytes from stream into b, returning the number of bytes read. The size of b will be increased if needed (i.e. if nb is greater than length(b) and enough bytes could be read), but it will never be decreased.\n\nIf all is true (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If all is false, at most one read call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the all option.\n\n\n\n\n\n","category":"function"},{"location":"#Base.readchomp","page":"LibSerialPort.jl – access serial ports","title":"Base.readchomp","text":"readchomp(x)\n\nRead the entirety of x as a string and remove a single trailing newline if there is one. Equivalent to chomp(read(x, String)).\n\nExamples\n\njulia> open(\"my_file.txt\", \"w\") do io\n           write(io, \"JuliaLang is a GitHub organization.\\nIt has many members.\\n\");\n       end;\n\njulia> readchomp(\"my_file.txt\")\n\"JuliaLang is a GitHub organization.\\nIt has many members.\"\n\njulia> rm(\"my_file.txt\");\n\n\n\n\n\n","category":"function"},{"location":"#Base.readavailable","page":"LibSerialPort.jl – access serial ports","title":"Base.readavailable","text":"readavailable(stream)\n\nRead available buffered data from a stream. Actual I/O is performed only if no data has already been buffered. The result is a Vector{UInt8}.\n\nwarning: Warning\nThe amount of data returned is implementation-dependent; for example it can depend on the internal choice of buffer size. Other functions such as read should generally be used instead.\n\n\n\n\n\n","category":"function"},{"location":"#Base.readline","page":"LibSerialPort.jl – access serial ports","title":"Base.readline","text":"readline(io::IO=stdin; keep::Bool=false)\nreadline(filename::AbstractString; keep::Bool=false)\n\nRead a single line of text from the given I/O stream or file (defaults to stdin). When reading from a file, the text is assumed to be encoded in UTF-8. Lines in the input end with '\\n' or \"\\r\\n\" or the end of an input stream. When keep is false (as it is by default), these trailing newline characters are removed from the line before it is returned. When keep is true, they are returned as part of the line.\n\nExamples\n\njulia> open(\"my_file.txt\", \"w\") do io\n           write(io, \"JuliaLang is a GitHub organization.\\nIt has many members.\\n\");\n       end\n57\n\njulia> readline(\"my_file.txt\")\n\"JuliaLang is a GitHub organization.\"\n\njulia> readline(\"my_file.txt\", keep=true)\n\"JuliaLang is a GitHub organization.\\n\"\n\njulia> rm(\"my_file.txt\")\n\n\n\n\n\n","category":"function"},{"location":"#Base.readlines","page":"LibSerialPort.jl – access serial ports","title":"Base.readlines","text":"readlines(io::IO=stdin; keep::Bool=false)\nreadlines(filename::AbstractString; keep::Bool=false)\n\nRead all lines of an I/O stream or a file as a vector of strings. Behavior is equivalent to saving the result of reading readline repeatedly with the same arguments and saving the resulting lines as a vector of strings.\n\nExamples\n\njulia> open(\"my_file.txt\", \"w\") do io\n           write(io, \"JuliaLang is a GitHub organization.\\nIt has many members.\\n\");\n       end\n57\n\njulia> readlines(\"my_file.txt\")\n2-element Vector{String}:\n \"JuliaLang is a GitHub organization.\"\n \"It has many members.\"\n\njulia> readlines(\"my_file.txt\", keep=true)\n2-element Vector{String}:\n \"JuliaLang is a GitHub organization.\\n\"\n \"It has many members.\\n\"\n\njulia> rm(\"my_file.txt\")\n\n\n\n\n\n","category":"function"},{"location":"#Base.eachline","page":"LibSerialPort.jl – access serial ports","title":"Base.eachline","text":"eachline(io::IO=stdin; keep::Bool=false)\neachline(filename::AbstractString; keep::Bool=false)\n\nCreate an iterable EachLine object that will yield each line from an I/O stream or a file. Iteration calls readline on the stream argument repeatedly with keep passed through, determining whether trailing end-of-line characters are retained. When called with a file name, the file is opened once at the beginning of iteration and closed at the end. If iteration is interrupted, the file will be closed when the EachLine object is garbage collected.\n\nExamples\n\njulia> open(\"my_file.txt\", \"w\") do io\n           write(io, \"JuliaLang is a GitHub organization.\\n It has many members.\\n\");\n       end;\n\njulia> for line in eachline(\"my_file.txt\")\n           print(line)\n       end\nJuliaLang is a GitHub organization. It has many members.\n\njulia> rm(\"my_file.txt\");\n\n\n\n\n\n","category":"function"},{"location":"#Base.write","page":"LibSerialPort.jl – access serial ports","title":"Base.write","text":"write(io::IO, x)\nwrite(filename::AbstractString, x)\n\nWrite the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).\n\nThe endianness of the written value depends on the endianness of the host system. Convert to/from a fixed endianness when writing/reading (e.g. using  htol and ltoh) to get results that are consistent across platforms.\n\nYou can write multiple values with the same write call. i.e. the following are equivalent:\n\nwrite(io, x, y...)\nwrite(io, x) + write(io, y...)\n\nExamples\n\nConsistent serialization:\n\njulia> fname = tempname(); # random temporary filename\n\njulia> open(fname,\"w\") do f\n           # Make sure we write 64bit integer in little-endian byte order\n           write(f,htol(Int64(42)))\n       end\n8\n\njulia> open(fname,\"r\") do f\n           # Convert back to host byte order and host integer type\n           Int(ltoh(read(f,Int64)))\n       end\n42\n\nMerging write calls:\n\njulia> io = IOBuffer();\n\njulia> write(io, \"JuliaLang is a GitHub organization.\", \" It has many members.\")\n56\n\njulia> String(take!(io))\n\"JuliaLang is a GitHub organization. It has many members.\"\n\njulia> write(io, \"Sometimes those members\") + write(io, \" write documentation.\")\n44\n\njulia> String(take!(io))\n\"Sometimes those members write documentation.\"\n\nUser-defined plain-data types without write methods can be written when wrapped in a Ref:\n\njulia> struct MyStruct; x::Float64; end\n\njulia> io = IOBuffer()\nIOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=0, maxsize=Inf, ptr=1, mark=-1)\n\njulia> write(io, Ref(MyStruct(42.0)))\n8\n\njulia> seekstart(io); read!(io, Ref(MyStruct(NaN)))\nBase.RefValue{MyStruct}(MyStruct(42.0))\n\n\n\n\n\n","category":"function"},{"location":"#Base.print-Tuple{IO, Any}","page":"LibSerialPort.jl – access serial ports","title":"Base.print","text":"print([io::IO], xs...)\n\nWrite to io (or to the default output stream stdout if io is not given) a canonical (un-decorated) text representation. The representation used by print includes minimal formatting and tries to avoid Julia-specific details.\n\nprint falls back to calling show, so most types should just define show. Define print if your type has a separate \"plain\" representation. For example, show displays strings with quotes, and print displays strings without quotes.\n\nstring returns the output of print as a string.\n\nExamples\n\njulia> print(\"Hello World!\")\nHello World!\njulia> io = IOBuffer();\n\njulia> print(io, \"Hello\", ' ', :World!)\n\njulia> String(take!(io))\n\"Hello World!\"\n\n\n\n\n\n","category":"method"},{"location":"#Additional-read-methods","page":"LibSerialPort.jl – access serial ports","title":"Additional read methods","text":"","category":"section"},{"location":"","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.jl – access serial ports","text":"read(::SerialPort)\nnonblocking_read(::SerialPort)\nbytesavailable(::SerialPort)","category":"page"},{"location":"#Base.read-Tuple{SerialPort}","page":"LibSerialPort.jl – access serial ports","title":"Base.read","text":"read(sp::SerialPort)\n\nReturn all incoming bytes currently available in the UART as a Vector{UInt8}.\n\nnote: Note\nJulia's Base module defines read(s::IO, nb::Integer = typemax(Int)). This method overrides the default value nb to bytesavailable(sp), which is useful for this context.\n\n\n\n\n\n","category":"method"},{"location":"#LibSerialPort.nonblocking_read-Tuple{SerialPort}","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.nonblocking_read","text":"nonblocking_read(sp::SerialPort)\n\nRead everything from the specified serial ports sp input buffer, one byte at a time, until it is empty. Returns a String.\n\n\n\n\n\n","category":"method"},{"location":"#Base.bytesavailable-Tuple{SerialPort}","page":"LibSerialPort.jl – access serial ports","title":"Base.bytesavailable","text":"bytesavailable(sp::SerialPort)\n\nReturn the number of bytes waiting in the input buffer.\n\n\n\n\n\n","category":"method"},{"location":"#Other-references","page":"LibSerialPort.jl – access serial ports","title":"Other references","text":"","category":"section"},{"location":"","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.jl – access serial ports","text":"The following are listed here only because they are referenced above:","category":"page"},{"location":"","page":"LibSerialPort.jl – access serial ports","title":"LibSerialPort.jl – access serial ports","text":"Base.ntoh\nBase.hton\nBase.ltoh\nBase.htol\nBase.stdout\nBase.string(xs...)","category":"page"},{"location":"#Base.ntoh","page":"LibSerialPort.jl – access serial ports","title":"Base.ntoh","text":"ntoh(x)\n\nConvert the endianness of a value from Network byte order (big-endian) to that used by the Host.\n\n\n\n\n\n","category":"function"},{"location":"#Base.hton","page":"LibSerialPort.jl – access serial ports","title":"Base.hton","text":"hton(x)\n\nConvert the endianness of a value from that used by the Host to Network byte order (big-endian).\n\n\n\n\n\n","category":"function"},{"location":"#Base.ltoh","page":"LibSerialPort.jl – access serial ports","title":"Base.ltoh","text":"ltoh(x)\n\nConvert the endianness of a value from Little-endian to that used by the Host.\n\n\n\n\n\n","category":"function"},{"location":"#Base.htol","page":"LibSerialPort.jl – access serial ports","title":"Base.htol","text":"htol(x)\n\nConvert the endianness of a value from that used by the Host to Little-endian.\n\n\n\n\n\n","category":"function"},{"location":"#Base.stdout","page":"LibSerialPort.jl – access serial ports","title":"Base.stdout","text":"stdout\n\nGlobal variable referring to the standard out stream.\n\n\n\n\n\n","category":"constant"},{"location":"#Base.string-Tuple","page":"LibSerialPort.jl – access serial ports","title":"Base.string","text":"string(xs...)\n\nCreate a string from any values using the print function.\n\nstring should usually not be defined directly. Instead, define a method print(io::IO, x::MyType). If string(x) for a certain type needs to be highly efficient, then it may make sense to add a method to string and define print(io::IO, x::MyType) = print(io, string(x)) to ensure the functions are consistent.\n\nExamples\n\njulia> string(\"a\", 1, true)\n\"a1true\"\n\n\n\n\n\n","category":"method"}]
}
